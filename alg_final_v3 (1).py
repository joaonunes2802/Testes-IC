# -*- coding: utf-8 -*-
"""Alg_final-V3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_dLzRMEO_K9slMpm3gTQUESqeIjLZfbe
"""

import random as rd
import pandas as pd
from scipy.optimize import minimize
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

# URLLC DRX possible configurations

deltaU = [2, 3, 4, 5, 6, 7, 8, 10, 14, 16, 20, 30, 32, 35, 40, 64, 80, 128, 160,
          256, 320, 512, 640]  # Set of Cycle Lenghts
fiU = [1, 2, 3, 4, 5, 6, 8, 10, 20, 30, 40, 50, 60, 80, 100, 200, 300, 400, 500,
       600, 800, 1000, 1200, 1600]  # Set of ON periods



omegaU = [25000, 30000, 40000, 50000]  #MHz
packetSizeU = [3000, 4000, 5000, 6000]

# eMBB DRX possible configurations
deltaE = [10, 20, 32, 40, 60, 64, 70, 80, 128, 160, 256, 320, 512, 640, 1024, 1280,
          2048, 2560, 5120, 10240, 20480]
fiE = [1, 2, 3, 4, 5, 6, 8, 10, 20, 30, 40, 50, 60, 80, 100, 200, 300, 400, 500,
       600, 800]
gamaE = [0, 10, 20, 32, 40, 60, 64, 70, 80, 128, 160, 256, 320, 512, 640, 1024, 1280,
         2048, 2560, 5120, 10240]


omegaE = [5000, 10000, 15000, 20000, 25000, 30000]  #MHz
packetSizeE = [6000, 7000, 8000, 90000]

# Power Comsuption
Pit = []
Pmax = 10000
beta = []

def adiciona(UEtype, dfUE, line):
  if UEtype == 1:
    linee = ["URLLC", 1, 1, 1, rd.choice(omegaU), rd.choice(packetSizeU), rd.randint(1, 2)]
    #soma += 50
    b = 0.4 + (0.6*(30/80))
    beta.append(b)

  elif UEtype == 2:
    linee = ["eMBB", 1, 1, 1, rd.choice(omegaE), rd.choice(packetSizeE), rd.randint(1, 2)]

    #soma += 20
    b = 0.4
    beta.append(b)

  dfUE.loc[line] = linee
  return dfUE

def inicializaUE(nURLLC, nEMBB):
  dfUE = pd.DataFrame(columns=['Usuário', 'Cycle Length [ms]', 'onTime [ms]', 'offset [ms]', 'BWP [MHz]', 'Packet Size [bytes]', 'Cell_Site'])
  if nURLLC > nEMBB:
    for i in range(0, (nURLLC + nEMBB)):
      if i < nEMBB:
        dfUE = adiciona(2, dfUE, i)
      else:
        dfUE = adiciona(1, dfUE, i)
  elif nURLLC < nEMBB:
    for i in range(0, (nURLLC + nEMBB)):
      if i < nURLLC:
        dfUE = adiciona(1, dfUE, i)
      else:
        dfUE = adiciona(2, dfUE, i)

  dfUE = scheduler(dfUE)
  dfUE = shannonCapacity(dfUE)
  return dfUE

def calculate_prbs_and_k(bwp):
    prbs_k_map = {
        5000: (25, 1),
        10000: (52, 2),
        15000: (79, 3),
        20000: (106, 4),
        25000: (133, 5),
        30000: (160, 6),
        40000: (216, 8),
        50000: (270, 10)
    }
    return prbs_k_map.get(bwp, (0, 1))

def calculate_signal(prbs, k):
    gains = np.random.rayleigh(scale=1, size=prbs // k)
    pBlocks = np.array(rd.choices(range(10, 30), weights=range(10, 30), k=prbs // k))
    return np.sum(gains * pBlocks)

def compute_snir(df1, df2):
    snir_list = np.array([])
    for row1 in df1.itertuples():
        bwp1 = row1[5]
        prbs, k = calculate_prbs_and_k(bwp1)
        signal1 = calculate_signal(prbs, k)

        interference = np.array([
            calculate_signal(prbs, k) for row2 in df2.itertuples()
            if row1[1] == row2[1] and bwp1 == row2[5]
        ])

        total_interference = np.sum(interference)
        snir = signal1 / (total_interference + 114)
        snir_list = np.append(snir_list, snir)

    return snir_list

def scheduler(df):
    df = df.sort_values(by='Cell_Site', ascending=True)
    df1 = df.query("Cell_Site == 1")
    df2 = df.query("Cell_Site == 2")

    snirUE1 = compute_snir(df1, df2)
    snirUE2 = compute_snir(df2, df1)

    df['SNIR'] = np.concatenate((snirUE1, snirUE2))
    return df

import math
def shannonCapacity(df):
  snirs = np.array(df['SNIR'])
  bwps = np.array(df['BWP [MHz]'])
  logaux = 1 + snirs
  log2 = np.log2(logaux)
  shannonCapacity = np.multiply(bwps, log2)
  shannonCapacity = shannonCapacity.tolist()
  df['Shannon_Capacity'] = shannonCapacity
  return df

def offsets_(UE):
  #Retorna o começo de cada offset

  cycle = UE[2]
  offsetsTimes = np.array([])
  qtdCycle = 100/cycle
  i = 0
  while i <= qtdCycle:
    offsetsTimes = np.append(offsetsTimes, cycle * i)
    i += 1
  #offsetsTimes = offsetsTimes.tolist()
  return offsetsTimes

def onTimes_(UE):
  # Retorna o começo de cada on

  offL = UE[4]
  cycle = UE[2]
  qtdCycle = 100/cycle
  onTimes = np.array([offL])
  i = 1
  while i <= qtdCycle:
    onTimes = np.append(onTimes, (cycle * i) + onTimes[0])
    i += 1

  # Calculate the power associated to this UE
  onL = UE[3]
  p = []
  for t in onTimes:
    for j in range(onL):
      p.append(1)
  Pit.append(sum(p))

  return onTimes

def inTimes_(UE):
  # Retorna o começo de cada in

  onL = UE[3]
  cycle = UE[2]
  offL = UE[4]
  qtdCycle = 100/cycle
  in_ = np.array([(offL + onL + 1)])
  i = 1
  while i <= qtdCycle:
    in_ = np.append(in_, (cycle * i) + in_[0])
    i += 1

  return in_

def timeOff(UE, tcs):
  # Return the latency of an offset for each tc

  offs = offsets_(UE).astype(int)
  ons = onTimes_(UE).astype(int)
  taO = np.zeros(len(tcs))
  aux = []
  if offs[0] != ons[0]:
    i = 0
    for tc2 in tcs:
      for off, on in zip(offs, ons):
        if tc2 in range(off, on):
          aux.append(on - tc2)
        else:
          aux.append(0)

      taO[i] = sum(aux)
      i += 1
      aux.clear()

  return taO

def timeIn(tcs, UE):
  # Return the latency of an in time for each tc

  cycle = UE[2] # Access column value using iloc
  onL = UE[3]
  offs = offsets_(UE).astype(int)
  ons = onTimes_(UE).astype(int)
  ins = inTimes_(UE).astype(int)
  aux = []
  taI = np.zeros(len(tcs))
  if cycle != onL:
    i = 0
    for tc2 in tcs:
      for inn, off, on in zip(ins, offs, ons):
        if (tc2 in range(inn, (off + cycle + 1))):
            aux.append((on + cycle) - tc2)
        else:
          aux.append(0)

      taI[i] = sum(aux)
      i += 1
      aux.clear()

  return taI

from scipy.stats import poisson
def arrivalTimePoisson():
  freq = [2, 3, 4]
  #mean_rate = 1/rd.choice(freq)
  mean_rate = rd.choice(freq)
  tc = poisson.rvs(mean_rate, size=400)
  tcs = [x for x in range(0, 401, int(tc.mean()))]
  return tcs

def latencyCycle(tc, dfUE):
  # Return the latency cycle for each UE
  lc = []
  for UE in dfUE.itertuples():
    taI = timeIn(tc, UE)
    taO = timeOff(UE, tc)
    latencyCycle = taI + taO
    lc.append(latencyCycle.tolist())
  dfUE['Latency_Cycle'] = lc
  #return dfUE

def calculate_kmax(bwp, user_type):
    kmax_map = {
        'URLLC': {25000: 5, 30000: 6, 40000: 8, 50000: 10},
        'eMBB': {
            25000: 5, 30000: 6, 20000: 4, 5000: 1,
            10000: 2, 15000: 3, 40000: 8, 50000: 10
        }
    }
    return kmax_map[user_type].get(bwp, 1)

def assign_dci_times(kmax_arr, on_time_arr, cycle_length_arr, columns):
    aux = np.zeros((len(kmax_arr), columns), dtype=int)

    for column in range(columns):
        aux_list = []

        for i, kmax in enumerate(kmax_arr):
            if i not in aux_list:
                indexes = np.where(kmax_arr == kmax)[0].tolist()
                aux_list.extend(indexes)

                k, group = 0, 0
                qtd_group = on_time_arr[i] // kmax

                for ue in indexes:
                    if k % kmax == 0 and k != 0:
                        group += 1
                    if group >= qtd_group and group % qtd_group == 0:
                        k = 0

                    if group < qtd_group:
                        aux[ue][column] = group
                    elif group < qtd_group * 2:
                        aux[ue][column] = group + cycle_length_arr[ue]
                    else:
                        aux[ue][column] = group + 2 * cycle_length_arr[ue]

                    k += 1

    return aux

def DCI(df):
    # Separar os dataframes por tipo de usuário
    df1 = df.query("Usuário == 'URLLC'")
    df2 = df.query("Usuário == 'eMBB'")

    # Preparar arrays de kmax, onTime, e Cycle Length
    kmax1 = np.array([calculate_kmax(bwp, 'URLLC') for bwp in df1['BWP [MHz]']])
    kmax2 = np.array([calculate_kmax(bwp, 'eMBB') for bwp in df2['BWP [MHz]']])

    # Atribuir tempos de DCI
    aux1 = assign_dci_times(kmax1, np.array(df1['onTime [ms]']), np.array(df1['Cycle Length [ms]']), len(df1['Latency_Cycle'].iloc[0]))
    aux2 = assign_dci_times(kmax2, np.array(df2['onTime [ms]']), np.array(df2['Cycle Length [ms]']), len(df2['Latency_Cycle'].iloc[0]))

    # Adicionar colunas de tempo de DCI
    df1['DCI_time'] = aux1.tolist()
    df2['DCI_time'] = aux2.tolist()

    # Concatenar e retornar o dataframe original com a coluna DCI_time
    df_combined = pd.concat([df1, df2], ignore_index=True)
    df['DCI_time'] = df_combined['DCI_time']
    # return df

def transmissionTime(df, tcs):
  sizes = np.array(df['Packet Size [bytes]'])
  capacities = np.array(df['Shannon_Capacity'])
  tT = []

  for size, capacity in zip(sizes, capacities):
    aux = []
    for tc in tcs:
      aux.append(size/capacity)  #196.08 bytes/ms = 196608 bytes/s = 1.5mbs
    tT.append(aux)

  df['Transmission_time'] = tT

  #return df

def totalLatency(df):
  latencyCycle = np.array(df['Latency_Cycle'])
  tT = np.array(df['Transmission_time'])
  dci = np.array(df['DCI_time'])

  totalLatencyaux = latencyCycle + dci
  totalLatency = totalLatencyaux + tT
  df['Total_Latency'] = totalLatency
  return df

def power(df):
  onLs = df['onTime [ms]'].tolist()
  powers = []
  p = []
  for onL in onLs:
    for i in range(onL):
      p.append(1)
    p = 400*p
    powers.append(sum(p))
    p.clear()
  df['Power'] = powers
  Pit = powers.copy()

def optimizer(x, dfUE):
    df1 = dfUE.query("Usuário == 'URLLC'")
    df2 = dfUE.query("Usuário == 'eMBB'")

    qtd1 = df1.shape[0]
    qtd2 = df2.shape[0]

    tc = arrivalTimePoisson()

    def update_rows(df, start_index, x_indices, delta, fi, gama=None):
        for j in range(20):
            line = df.index[df['Cycle Length [ms]'] == 1].min()
            dij = int(x[x_indices[0] + j])
            fij = int(x[x_indices[1] + j])
            df.at[line, 'Cycle Length [ms]'] = delta[dij]
            df.at[line, 'onTime [ms]'] = fi[fij]
            if gama is not None:
                gij = int(x[x_indices[2] + j])
                df.at[line, 'offset [ms]'] = gama[gij]
            else:
                df.at[line, 'offset [ms]'] = int(0.5 * fi[fij])

    def process_ue(df, qtd, x_indices, delta, fi, gama=None):
        for k in range(qtd // 20):
          #update_rows(df, k, x_indices[k*60:(k+1)*60], delta, fi, gama)
          update_rows(df, k, x_indices, delta, fi, gama)

    if qtd1 < qtd2:
        process_ue(df1, qtd1, [0, 20, 40], deltaU, fiU)
        process_ue(df2, qtd2, [60, 80, 100], deltaE, fiE, gamaE)
    else:
        process_ue(df2, qtd2, [0, 20, 40], deltaE, fiE, gamaE)
        process_ue(df1, qtd1, [120, 140, 160], deltaU, fiU)

    dfUEaux = pd.concat([df1, df2], ignore_index=True)
    dfUE.sort_values(by=['Usuário'], ascending=False, inplace=True)
    dfUE.update(dfUEaux)

    latencyCycle(tc, dfUE)
    DCI(dfUE)
    transmissionTime(dfUE, tc)
    totalLatency(dfUE)
    power(dfUE)

    latency = np.array(list(dfUE['Total_Latency']))

    return sum((beta[i] * Pit[i]) / (Pmax * latency[i].sum()) for i in range(100))

#restricoes
def restricao1(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaI = np.array([])
  for i in range(0, 20):
    indexDU = int(x[i])
    indexFU = int(x[i+20])
    deltas = np.append(deltas, deltaU[indexDU])
    fiIs = np.append(fiIs, fiU[indexFU])

  times = deltas - fiIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao2(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaI = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 40])
    fij = int(x[60 + j])
    deltas = np.append(deltas, deltaU[dij])
    fiIs = np.append(fiIs, fiU[fij])

  times = deltas - fiIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao3(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 60])
    fij = int(x[80+j])
    gij = int(x[100+j])

    deltas = np.append(deltas, deltaE[dij])
    fiIs = np.append(fiIs, fiE[fij])
    gamaIs = np.append(gamaIs, gamaE[gij])

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao4(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 120])
    fij = int(x[140+j])
    gij = int(x[160+j])

    deltas = np.append(deltas, deltaE[dij])
    fiIs = np.append(fiIs, fiE[fij])
    gamaIs = np.append(gamaIs, gamaE[gij])

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao5(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 180])
    fij = int(x[200+j])
    gij = int(x[220+j])

    deltas = np.append(deltas, deltaE[dij])
    fiIs = np.append(fiIs, fiE[fij])
    gamaIs = np.append(gamaIs, gamaE[gij])


  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao6(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 240])
    fij = int(x[260+j])
    gij = int(x[280+j])

    deltas = np.append(deltas, deltaE[dij])
    fiIs = np.append(fiIs, fiE[fij])
    gamaIs = np.append(gamaIs, gamaE[gij])

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux


cons1 = [{'type': 'ineq', 'fun': restricao1},
        {'type': 'ineq', 'fun': restricao2},
        {'type': 'ineq', 'fun': restricao3},
         {'type': 'ineq', 'fun': restricao4},
         {'type': 'ineq', 'fun': restricao5},
         {'type': 'ineq', 'fun': restricao6}]


a = [0, 20]

bnds1 = 300*[a]

#restricoes2

def restricao7(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j])
    fij = int(x[20+j])
    gij = int(x[40+j])

    deltas = np.append(deltas, deltaE[dij])
    fiIs = np.append(fiIs, fiE[fij])
    gamaIs = np.append(gamaIs, gamaE[gij])

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao8(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 60])
    fij = int(x[80+j])
    gij = int(x[100+j])

    deltas = np.append(deltas, deltaE[dij])
    fiIs = np.append(fiIs, fiE[fij])
    gamaIs = np.append(gamaIs, gamaE[gij])

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao9(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 120])
    fij = int(x[140+j])

    deltas = np.append(deltas, deltaU[dij])
    fiIs = np.append(fiIs, fiU[fij])
    gamaIs = np.append(gamaIs, int(0.5*fiU[fij]))

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao10(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 160])
    fij = int(x[180+j])

    deltas = np.append(deltas, deltaU[dij])
    fiIs = np.append(fiIs, fiU[fij])
    gamaIs = np.append(gamaIs, int(0.5*fiU[fij]))

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao11(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 200])
    fij = int(x[220+j])

    deltas = np.append(deltas, deltaU[dij])
    fiIs = np.append(fiIs, fiU[fij])
    gamaIs = np.append(gamaIs, int(0.5*fiU[fij]))

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao12(x):
  deltas = np.array([])
  fiIs = np.array([])
  gamaIs = np.array([])
  for j in range(0, 20):
    dij = int(x[j + 240])
    fij = int(x[260+j])

    deltas = np.append(deltas, deltaU[dij])
    fiIs = np.append(fiIs, fiU[fij])
    gamaIs = np.append(gamaIs, int(0.5*fiU[fij]))

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

cons2 = [{'type': 'ineq', 'fun': restricao7},
        {'type': 'ineq', 'fun': restricao8},
        {'type': 'ineq', 'fun': restricao9},
        {'type': 'ineq', 'fun': restricao10},
        {'type': 'ineq', 'fun': restricao11},
        {'type': 'ineq', 'fun': restricao12}]


b = [0, 20]

bnds2 = 280*[b]

from time import time

# estimativa inicial
x01 = 300*[0]
x02 = 280*[0]

NURLLC = 20
NeMBB = 80

dfUE1 = inicializaUE(NURLLC, NeMBB)
solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE1,))

NURLLC = 40
NeMBB = 60

dfUE2 = inicializaUE(NURLLC, NeMBB)
solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE2,))

NURLLC = 60
NeMBB = 40

dfUE3 = inicializaUE(NURLLC, NeMBB)
solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE3,))

NURLLC = 80
NeMBB = 20

dfUE4 = inicializaUE(NURLLC, NeMBB)
solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE4,))

df1U = dfUE1.query("Usuário == 'URLLC'")
df2U = dfUE2.query("Usuário == 'URLLC'")
df3U = dfUE3.query("Usuário == 'URLLC'")
df4U = dfUE4.query("Usuário == 'URLLC'")

dfU = pd.concat([df1U, df2U, df3U, df4U])
del df1U, df2U, df3U, df4U


df1E = dfUE1.query("Usuário == 'eMBB'")
df2E = dfUE2.query("Usuário == 'eMBB'")
df3E = dfUE3.query("Usuário == 'eMBB'")
df4E = dfUE4.query("Usuário == 'eMBB'")

dfE = pd.concat([df1E, df2E, df3E, df4E])
del df1E, df2E, df3E, df4E

del dfUE1, dfUE2, dfUE3, dfUE4

latMaxU = dfU['Total_Latency']
lMaxU = []
for indice, lista in enumerate(latMaxU):
  lMaxU.append(max(lista))

dfU['Maximum_Latency'] = lMaxU

latMaxE = dfE['Total_Latency']
lMaxE = []
for indice, lista in enumerate(latMaxE):
  lMaxE.append(max(lista))

dfE['Maximum_Latency'] = lMaxE

latCycU = dfU['Latency_Cycle']
lCycU = []
for indice, lista in enumerate(latCycU):
  lCycU.append(max(lista))

dfU['Maximum_Cycle_Latency'] = lCycU

latCycE = dfE['Latency_Cycle']
lCycE = []
for indice, lista in enumerate(latCycE):
  lCycE.append(max(lista))

dfE['Maximum_Cycle_Latency'] = lCycE

latDCIU = dfU['DCI_time']
lDCIU = []
for indice, lista in enumerate(latDCIU):
  lDCIU.append(max(lista))

dfU['Maximum_DCI'] = lDCIU

latDCIE = dfE['DCI_time']
lDCIE = []
for indice, lista in enumerate(latDCIE):
  lDCIE.append(max(lista))

dfE['Maximum_DCI'] = lDCIE

latTransU = dfU['Transmission_time']
lTransU = []
for indice, lista in enumerate(latTransU):
  lTransU.append(max(lista))

dfU['Maximum_Transmission_Time'] = lTransU

latTransE = dfE['Transmission_time']
lTransE = []
for indice, lista in enumerate(latTransE):
  lTransE.append(max(lista))

dfE['Maximum_Transmission_Time'] = lTransE

powerU = np.array(dfU['Power'])
powerE = np.array(dfE['Power'])

sortPU_1 = np.sort(powerU)
pPU_1 = 1.0 * np.arange(len(powerU)) / float(len(powerU) - 1)

sortPE_1 = np.sort(powerE)
pPE_1 = 1.0 * np.arange(len(powerE)) / float(len(powerE) - 1)

capacityU = np.array(dfU['Shannon_Capacity'])
capacityE = np.array(dfE['Shannon_Capacity'])

sortCaU_1 = np.sort(capacityU)
pCaU_1 = 1.0 * np.arange(len(capacityU)) / float(len(capacityU) - 1)

sortCaE_1 = np.sort(capacityE)
pCaE_1 = 1.0 * np.arange(len(capacityE)) / float(len(capacityE) - 1)

latencyU_1 = np.array(list(dfU['Total_Latency'])).flatten()

latencyE_1 = np.array(list(dfE['Total_Latency'])).flatten()

sortlU_1 = np.sort(latencyU_1)
plU_1 = 1.0 * np.arange(len(latencyU_1)) / float(len(latencyU_1) - 1)

sortlE_1 = np.sort(latencyE_1)
plE_1 = 1.0 * np.arange(len(latencyE_1)) / float(len(latencyE_1) - 1)

latencyUaux = None
latencyU_1 = None
latencyEaux = None
latencyE_1 = None

dciU_1 = np.array(list(dfU['DCI_time'])).flatten()

dciE_1 = np.array(list(dfE['DCI_time'])).flatten()

sortdciU_1 = np.sort(dciU_1)
pdciU_1 = 1.0 * np.arange(len(dciU_1)) / float(len(dciU_1) - 1)

sortdciE_1 = np.sort(dciE_1)
pdciE_1 = 1.0 * np.arange(len(dciE_1)) / float(len(dciE_1) - 1)

dciUaux = None
dciU_1 = None
dciEaux = None
dciE_1 = None

transmitU_1 = np.array(list(dfU['Transmission_time'])).flatten()

transmitE_1 = np.array(list(dfE['Transmission_time'])).flatten()

sorttransmitU_1 = np.sort(transmitU_1)
ptransmitU_1 = 1.0 * np.arange(len(transmitU_1)) / float(len(transmitU_1) - 1)

sorttransmitE_1 = np.sort(transmitE_1)
ptransmitE_1 = 1.0 * np.arange(len(transmitE_1)) / float(len(transmitE_1) - 1)

transmitUaux = None
transmitU_1 = None
transmitEaux = None
transmitE_1 = None

cycleLaU_1 = np.array(list(dfU['Latency_Cycle'])).flatten()

cycleLaE_1 = np.array(list(dfE['Latency_Cycle'])).flatten()

sortcycleLaU_1 = np.sort(cycleLaU_1)
pcycleLaU_1 = 1.0 * np.arange(len(cycleLaU_1)) / float(len(cycleLaU_1) - 1)

sortcycleLaE_1 = np.sort(cycleLaE_1)
pcycleLaE_1 = 1.0 * np.arange(len(cycleLaE_1)) / float(len(cycleLaE_1) - 1)

cycleLaUaux = None
cycleLaU_1 = None
cycleLaEaux = None
cycleLaE_1 = None

dfU.boxplot(column=['Shannon_Capacity'])
plt.show()

dfU.boxplot(column=['Maximum_Latency', 'Maximum_Cycle_Latency', 'Maximum_DCI', 'Maximum_Transmission_Time'])
plt.show()

dfU['Maximum_Latency'].hist()
plt.show()

dfU['Cycle Length [ms]'].hist()
plt.show()

dfU['onTime [ms]'].hist()
plt.show()

dfU['offset [ms]'].hist()
plt.show()

dfU.plot.scatter(x='Shannon_Capacity', y='Maximum_Latency')
plt.show()

dfU.plot.scatter(x='Cycle Length [ms]', y='Maximum_Latency')
plt.show()

dfU.plot.scatter(x='onTime [ms]', y='Maximum_Latency')
plt.show()

dfU.plot.scatter(x='offset [ms]', y='Maximum_Latency')
plt.show()

dfE.boxplot(column=['Shannon_Capacity'])
plt.show()

dfE.boxplot(column=['Maximum_Latency', 'Maximum_Cycle_Latency', 'Maximum_DCI', 'Maximum_Transmission_Time'])
plt.show()

dfE['Maximum_Latency'].hist()
plt.show()

dfE['Cycle Length [ms]'].hist()
plt.show()

dfE['onTime [ms]'].hist()
plt.show()

dfE['offset [ms]'].hist()
plt.show()

dfE.plot.scatter(x='Shannon_Capacity', y='Maximum_Latency')
plt.show()

dfE.plot.scatter(x='Cycle Length [ms]', y='Maximum_Latency')
plt.show()

dfE.plot.scatter(x='onTime [ms]', y='Maximum_Latency')
plt.show()

dfE.plot.scatter(x='offset [ms]', y='Maximum_Latency')
plt.show()

del dfU, dfE

"""#**Algorithm 2**"""

NURLLC = 20
NeMBB = 80


dfUE1 = inicializaUE(NURLLC, NeMBB)
dfUE1 = dfUE1.sort_values(by = 'Shannon_Capacity', ascending=False, ignore_index=True)
solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE1,))

NURLLC = 40
NeMBB = 60

dfUE2 = inicializaUE(NURLLC, NeMBB)
dfUE2 = dfUE2.sort_values(by = 'Shannon_Capacity', ascending=False, ignore_index=True)
solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE2,))

NURLLC = 60
NeMBB = 40

dfUE3 = inicializaUE(NURLLC, NeMBB)
dfUE3 = dfUE3.sort_values(by = 'Shannon_Capacity', ascending=False, ignore_index=True)
solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE3,))

NURLLC = 80
NeMBB = 20

dfUE4 = inicializaUE(NURLLC, NeMBB)
dfUE4 = dfUE4.sort_values(by = 'Shannon_Capacity', ascending=False, ignore_index=True)
solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE4,))

df1U = dfUE1.query("Usuário == 'URLLC'")
df2U = dfUE2.query("Usuário == 'URLLC'")
df3U = dfUE3.query("Usuário == 'URLLC'")
df4U = dfUE4.query("Usuário == 'URLLC'")

dfU = pd.concat([df1U, df2U, df3U, df4U])
del df1U, df2U, df3U, df4U


df1E = dfUE1.query("Usuário == 'eMBB'")
df2E = dfUE2.query("Usuário == 'eMBB'")
df3E = dfUE3.query("Usuário == 'eMBB'")
df4E = dfUE4.query("Usuário == 'eMBB'")

dfE = pd.concat([df1E, df2E, df3E, df4E])
del df1E, df2E, df3E, df4E

del dfUE1, dfUE2, dfUE3, dfUE4

latMaxU = dfU['Total_Latency']
lMaxU = []
for indice, lista in enumerate(latMaxU):
  lMaxU.append(max(lista))

dfU['Maximum_Latency'] = lMaxU

latMaxE = dfE['Total_Latency']
lMaxE = []
for indice, lista in enumerate(latMaxE):
  lMaxE.append(max(lista))

dfE['Maximum_Latency'] = lMaxE

latCycU = dfU['Latency_Cycle']
lCycU = []
for indice, lista in enumerate(latCycU):
  lCycU.append(max(lista))

dfU['Maximum_Cycle_Latency'] = lCycU

latCycE = dfE['Latency_Cycle']
lCycE = []
for indice, lista in enumerate(latCycE):
  lCycE.append(max(lista))

dfE['Maximum_Cycle_Latency'] = lCycE

latDCIU = dfU['DCI_time']
lDCIU = []
for indice, lista in enumerate(latDCIU):
  lDCIU.append(max(lista))

dfU['Maximum_DCI'] = lDCIU

latDCIE = dfE['DCI_time']
lDCIE = []
for indice, lista in enumerate(latDCIE):
  lDCIE.append(max(lista))

dfE['Maximum_DCI'] = lDCIE

latTransU = dfU['Transmission_time']
lTransU = []
for indice, lista in enumerate(latTransU):
  lTransU.append(max(lista))

dfU['Maximum_Transmission_Time'] = lTransU

latTransE = dfE['Transmission_time']
lTransE = []
for indice, lista in enumerate(latTransE):
  lTransE.append(max(lista))

dfE['Maximum_Transmission_Time'] = lTransE

powerU2 = np.array(dfU['Power'])
powerE2 = np.array(dfE['Power'])

sortPU_2 = np.sort(powerU2)
pPU_2 = 1.0 * np.arange(len(powerU2)) / float(len(powerU2) - 1)

sortPE_2 = np.sort(powerE2)
pPE_2 = 1.0 * np.arange(len(powerE2)) / float(len(powerE2) - 1)

capacityU = np.array(dfU['Shannon_Capacity'])
capacityE = np.array(dfE['Shannon_Capacity'])

sortCaU_2 = np.sort(capacityU)
pCaU_2 = 1.0 * np.arange(len(capacityU)) / float(len(capacityU) - 1)

sortCaE_2 = np.sort(capacityE)
pCaE_2 = 1.0 * np.arange(len(capacityE)) / float(len(capacityE) - 1)

latencyU_2 = np.array(list(dfU['Total_Latency'])).flatten()
latencyE_2 = np.array(list(dfE['Total_Latency'])).flatten()

sortlU_2 = np.sort(latencyU_2)
plU_2 = 1.0 * np.arange(len(latencyU_2)) / float(len(latencyU_2) - 1)

sortlE_2 = np.sort(latencyE_2)
plE_2 = 1.0 * np.arange(len(latencyE_2)) / float(len(latencyE_2) - 1)

latencyUaux = None
latencyU_2 = None
latencyEaux = None
latencyE_2 = None

dciU_2 = np.array(list(dfU['DCI_time'])).flatten()
dciE_2 = np.array(list(dfE['DCI_time'])).flatten()

sortdciU_2 = np.sort(dciU_2)
pdciU_2 = 1.0 * np.arange(len(dciU_2)) / float(len(dciU_2) - 1)

sortdciE_2 = np.sort(dciE_2)
pdciE_2 = 1.0 * np.arange(len(dciE_2)) / float(len(dciE_2) - 1)

dciUaux = None
dciU_2 = None
dciEaux = None
dciE_2 = None

transmitU_2 = np.array(list(dfU['Transmission_time'])).flatten()
transmitE_2 = np.array(list(dfE['Transmission_time'])).flatten()

sorttransmitU_2 = np.sort(transmitU_2)
ptransmitU_2 = 1.0 * np.arange(len(transmitU_2)) / float(len(transmitU_2) - 1)

sorttransmitE_2 = np.sort(transmitE_2)
ptransmitE_2 = 1.0 * np.arange(len(transmitE_2)) / float(len(transmitE_2) - 1)

transmitUaux = None
transmitU_2 = None
transmitEaux = None
transmitE_2 = None

cycleLaU_2 = np.array(list(dfU['Latency_Cycle'])).flatten()
cycleLaE_2 = np.array(list(dfE['Latency_Cycle'])).flatten()

sortcycleLaU_2 = np.sort(cycleLaU_2)
pcycleLaU_2 = 1.0 * np.arange(len(cycleLaU_2)) / float(len(cycleLaU_2) - 1)

sortcycleLaE_2 = np.sort(cycleLaE_2)
pcycleLaE_2 = 1.0 * np.arange(len(cycleLaE_2)) / float(len(cycleLaE_2) - 1)

cycleLaUaux = None
cycleLaU_2 = None
cycleLaEaux = None
cycleLaE_2 = None

dfU.boxplot(column=['Shannon_Capacity'])
plt.show()

dfU.boxplot(column=['Maximum_Latency', 'Maximum_Cycle_Latency', 'Maximum_DCI', 'Maximum_Transmission_Time'])
plt.show()

dfU['Maximum_Latency'].hist()
plt.show()

dfU['Cycle Length [ms]'].hist()
plt.show()

dfU['onTime [ms]'].hist()
plt.show()

dfU['offset [ms]'].hist()
plt.show()

dfU.plot.scatter(x='Shannon_Capacity', y='Maximum_Latency')
plt.show()

dfU.plot.scatter(x='Cycle Length [ms]', y='Maximum_Latency')
plt.show()

dfU.plot.scatter(x='onTime [ms]', y='Maximum_Latency')
plt.show()

dfU.plot.scatter(x='offset [ms]', y='Maximum_Latency')
plt.show()

dfE.boxplot(column=['Shannon_Capacity'])
plt.show()

dfE.boxplot(column=['Maximum_Latency', 'Maximum_Cycle_Latency', 'Maximum_DCI', 'Maximum_Transmission_Time'])
plt.show()

dfE['Maximum_Latency'].hist()
plt.show()

dfE['Cycle Length [ms]'].hist()
plt.show()

dfE['onTime [ms]'].hist()
plt.show()

dfE['offset [ms]'].hist()
plt.show()

dfE.plot.scatter(x='Shannon_Capacity', y='Maximum_Latency')
plt.show()

dfE.plot.scatter(x='Cycle Length [ms]', y='Maximum_Latency')
plt.show()

dfE.plot.scatter(x='onTime [ms]', y='Maximum_Latency')
plt.show()

dfE.plot.scatter(x='offset [ms]', y='Maximum_Latency')
plt.show()

del dfU, dfE

"""#**CDF`s Plot**"""

plt.plot(sortCaU_1, pCaU_1, "-g", label="Algorithm 1")
plt.plot(sortCaU_2, pCaU_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Shannon Capacity URLLC', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20

plt.show()

plt.plot(sortlU_1, plU_1, "-g", label="Algorithm 1")
plt.plot(sortlU_2, plU_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Total Latency URLLC [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20

plt.show()

plt.plot(sortdciU_1, pdciU_1, "-g", label="Algorithm 1")
plt.plot(sortdciU_2, pdciU_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('DCI Latency URLLC [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20

plt.show()

plt.plot(sorttransmitU_1, ptransmitU_1, "-g", label="Algorithm 1")
plt.plot(sorttransmitU_2, ptransmitU_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Transmission Latency URLLC [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20

plt.show()

plt.plot(sortcycleLaU_1, pcycleLaU_1, "-g", label="Algorithm 1")
plt.plot(sortcycleLaU_2, pcycleLaU_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Sleep Latency URLLC [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20

plt.show()

plt.plot(sortCaE_1, pCaE_1, "-g", label="Algorithm 1")
plt.plot(sortCaE_2, pCaE_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Shanon Capacity eMBB [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.show()

plt.plot(sortlE_1, plE_1, "-g", label="Algorithm 1")
plt.plot(sortlE_2, plE_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Total Latency eMBB [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.show()

plt.plot(sortdciE_1, pdciE_1, "-g", label="Algorithm 1")
plt.plot(sortdciE_2, pdciE_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('DCI Latency eMBB [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.show()

plt.plot(sorttransmitE_1, ptransmitE_2, "-g", label="Algorithm 1")
plt.plot(sorttransmitE_2, ptransmitE_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Transmission Latency eMBB [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.show()

plt.plot(sortcycleLaE_1, pcycleLaE_1, "-g", label="Algorithm 1")
plt.plot(sortcycleLaE_2, pcycleLaE_2, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Sleep Latency eMBB [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.show()

plt.plot(sortPU_1, pPU_1, "-g", label="Algorithm 1")
plt.plot(sortPU_2, pPU_1, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Power consumption [mW] - URLLC', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.show()

plt.plot(sortPE_1, pPE_1, "-g", label="Algorithm 1")
plt.plot(sortPE_2, pPE_1, "-r", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Power consumption [mW] - eMBB', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.show()

tc = arrivalTimePoisson()
print(tc)