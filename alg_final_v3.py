# -*- coding: utf-8 -*-
"""Alg_final-V3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_dLzRMEO_K9slMpm3gTQUESqeIjLZfbe
"""

import random as rd
import pandas as pd
from scipy.optimize import minimize
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

# K UEs
#UEs = []
# UEs = [ue0, ue1]
#ue0 = [[dij], [fij], [gij], [wij]]

#----- C-DRX Parameters -----

# available bandwidth
W = 2500000  #2.5 GHz

# Subcarrier spacing
sp = 692.5  #692.5 KHz

# Frequency of one PRB
fp = 180  #180 KHz

# Total number of PRBs
prbs = int((W - (2*sp))//fp)


# URLLC DRX possible configurations

deltaU = [2, 3, 4, 5, 6, 7, 8, 10, 14, 16, 20, 30, 32, 35, 40, 64, 80, 128, 160,
          256, 320, 512, 640]  # Set of Cycle Lenghts
fiU = [1, 2, 3, 4, 5, 6, 8, 10, 20, 30, 40, 50, 60, 80, 100, 200, 300, 400, 500,
       600, 800, 1000, 1200, 1600]  # Set of ON periods



omegaU = [25000, 30000, 40000, 50000]  #MHz

# eMBB DRX possible configurations
deltaE = [10, 20, 32, 40, 60, 64, 70, 80, 128, 160, 256, 320, 512, 640, 1024, 1280,
          2048, 2560, 5120, 10240]
fiE = [1, 2, 3, 4, 5, 6, 8, 10, 20, 30, 40, 50, 60, 80, 100, 200, 300, 400, 500,
       600]
gamaE = [0, 10, 20, 32, 40, 60, 64, 70, 80, 128, 160, 256, 320, 512, 640, 1024, 1280,
         2048, 2560, 5120]


omegaE = [5000, 10000, 15000, 20000, 25000, 30000]  #MHz

# Power Comsuption
Pit = []
Pmax = 80


# Delay constraint URLLC
Limax = 4  #4ms
Lit = []

beta = []

def adiciona(UEtype, dfUE, line):
  index = [0]
  if UEtype == 1:
    soma = 0

    linee = ["URLLC", 1, 1, 1, rd.choice(omegaU), 360, rd.randint(1, 2)]
    soma += 50
    b = 0.4 + (0.6*((soma - 20)/80))
    beta.append(b)

  elif UEtype == 2:
    soma = 0

    linee = ["eMBB", 1, 1, 1, rd.choice(omegaE), 6516, rd.randint(1, 2)]

    soma += 20
    b = 0.4 + (0.6*((soma - 20)/80))
    beta.append(b)

  dfUE.loc[line] = linee
  return dfUE

def inicializaUE(nURLLC, nEMBB):
  dfUE = pd.DataFrame(columns=['Usuário', 'Cycle Length [ms]', 'onTime [ms]', 'offset [ms]', 'BWP [MHz]', 'Packet Size [bytes]', 'Cell_Site'])
  if nURLLC > nEMBB:
    for i in range(0, (nURLLC + nEMBB)):
      if i < nEMBB:
        dfUE = adiciona(2, dfUE, i)
      else:
        dfUE = adiciona(1, dfUE, i)
  elif nURLLC < nEMBB:
    for i in range(0, (nURLLC + nEMBB)):
      if i < nURLLC:
        dfUE = adiciona(1, dfUE, i)
      else:
        dfUE = adiciona(2, dfUE, i)

  dfUE = scheduler(dfUE)
  dfUE = shannonCapacity(dfUE)
  return dfUE

def scheduler(df):
  df = df.sort_values(by = 'Cell_Site', ascending = True)
  df1 = df.query("Cell_Site == 1")
  df2 = df.query("Cell_Site == 2")
  snirUE1 = np.array([])
  snirUE2 = np.array([])
  k = 0
  prbs = 0
  for row1 in df1.itertuples():
    bwp1 = row1[5]
    if bwp1 == 5000:
      prbs = 25
      k = 1
    elif bwp1 == 10000:
      prbs = 52
      k = 2
    elif bwp1 == 15000:
      prbs = 79
      k = 3
    elif bwp1 == 20000:
      prbs = 106
      k = 4
    elif bwp1 == 25000:
      prbs = 133
      k = 5
    elif bwp1 == 30000:
      prbs = 160
      k = 6
    elif bwp1 == 40000:
      prbs = 216
      k = 8
    elif bwp1 == 50000:
      prbs = 270
      k = 10

    gains1 = np.random.rayleigh(scale = 1, size = (prbs//k))
    pBlocks1 = np.array(rd.choices(range(10, 30), weights=range(10, 30), k = (prbs//k)))
    signal1 = np.sum(gains1*pBlocks1)

    sliceType1 = row1[1]
    interference = np.array([])
    for row2 in df2.itertuples():
      sliceType2 = row2[1]
      bwp2 = row2[5]
      if (sliceType1 == sliceType2) and (bwp1 == bwp2):
        gains2 = np.random.rayleigh(scale = 1, size = (prbs//k))
        pBlocks2 = np.array(rd.choices(range(10, 30), weights = range(10, 30), k = (prbs//k)))
        signal2 = np.sum(gains2*pBlocks2)

        interference = np.append(interference, signal2)

    totalInterferenceUe = np.sum(interference)
    snirUE = signal1/(totalInterferenceUe + 114)
    snirUE1 = np.append(snirUE1, snirUE)

  for row2 in df2.itertuples():
    bwp2 = row2[5]
    if bwp2 == 5000:
      prbs = 25
      k = 1
    elif bwp2 == 10000:
      prbs = 52
      k = 2
    elif bwp2 == 15000:
      prbs = 79
      k = 3
    elif bwp2 == 20000:
      prbs = 106
      k = 4
    elif bwp2 == 25000:
      prbs = 133
      k = 5
    elif bwp2 == 30000:
      prbs = 160
      k = 6
    elif bwp2 == 40000:
      prbs = 216
      k = 8
    elif bwp2 == 50000:
      prbs = 270
      k = 10

    gains2 = np.random.rayleigh(scale = 1, size = (prbs//k))
    pBlocks2 = np.array(rd.choices(range(10, 30), weights = range(10, 30), k = (prbs//k)))
    signal2 = np.sum(gains2*pBlocks2)

    sliceType2 = row2[1]
    interference = np.array([])
    for row1 in df1.itertuples():
      sliceType1 = row1[1]
      bwp1 = row1[5]
      if (sliceType1 == sliceType2) and (bwp1 == bwp2):
        gains1 = np.random.rayleigh(scale = 1, size = (prbs//k))
        pBlocks1 = np.array(rd.choices(range(10, 30), weights = range(10, 30), k = (prbs//k)))
        signal1 = np.sum(gains1*pBlocks1)

        interference = np.append(interference, signal1)

    totalInterferenceUe = np.sum(interference)
    snirUE = signal2/(totalInterferenceUe + 114)
    snirUE2 = np.append(snirUE2, snirUE)

  SNIR = np.concatenate((snirUE1, snirUE2))
  SNIRlist = SNIR.tolist()
  df.loc[:, 'SNIR'] = SNIRlist
  return df

import math
def shannonCapacity(df):
  snirs = list(df['SNIR'])
  bwps = list(df['BWP [MHz]'])
  shannonCapacity = []

  for bwp, snirUE in zip(bwps, snirs):
    capacity = bwp*math.log2(1 + snirUE)

    shannonCapacity.append(capacity)

  df['Shannon_Capacity'] = shannonCapacity
  return df

def offsets_(UE):
  #Retorna o começo de cada offset

  cycle = UE[2]
  offsetsTimes = []
  qtdCycle = 400/cycle
  i = 0
  while i <= qtdCycle:
    offsetsTimes.append(cycle * i)
    i += 1

  return offsetsTimes

def onTimes_(UE):
  # Retorna o começo de cada on

  offL = UE[4]
  cycle = UE[2]
  qtdCycle = 400/cycle
  onTimes = [offL]
  i = 1
  while i <= qtdCycle:
    onTimes.append(onTimes[0] + (cycle * i))
    i += 1

  # Calculate the power associated to this UE
  onL = UE[3]
  p = []
  for t in onTimes:
    for j in range(onL):
      p.append(1)
  Pit.append(sum(p))

  return onTimes

def inTimes_(UE):
  # Retorna o começo de cada in

  onL = UE[3]
  cycle = UE[2]
  offL = UE[4]
  qtdCycle = 400/cycle
  in_ = [(offL + onL + 1)]
  i = 1
  while i <= qtdCycle:
    in_.append(in_[0] + (cycle* i))
    i += 1

  return in_

def timeOff(UE, tcs):
  # Return the latency of an offset for each tc

  offs = offsets_(UE)
  ons = onTimes_(UE)
  taO = []
  aux = []

  for tc2 in tcs:
    for off, on in zip(offs, ons):
      if offs[0] == ons[0]:
        aux.append(0)

      elif tc2 in range(off, on):
        aux.append(on - tc2)
      else:
        aux.append(0)

    taO.append(sum(aux))
    aux.clear()

  return np.array(taO)

def timeIn(tcs, UE):
  # Return the latency of an in time for each tc

  cycle = UE[2] # Access column value using iloc
  onL = UE[3]
  offs = offsets_(UE)
  ons = onTimes_(UE)
  ins = inTimes_(UE)
  aux = []
  taI = []
  for tc2 in tcs:
    for inn, off, on in zip(ins, offs, ons):
      if (tc2 in range(inn, (off + cycle + 1))):
        if cycle == onL:
          aux.append(0)
        else:
          aux.append((on + cycle) - tc2)
      else:
        aux.append(0)

    taI.append(sum(aux))
    aux.clear()

  return np.array(taI)

def latencyCycle(tc, dfUE):
  # Return the latency cycle for each UE
  lc = []
  for UE in dfUE.itertuples():
    taI = timeIn(tc, UE)
    taO = timeOff(UE, tc)
    latencyCycle = taI + taO
    lc.append(latencyCycle.tolist())
  dfUE['Latency_Cycle'] = lc
  return dfUE

from scipy.stats import poisson
def arrivalTimePoisson():
  mean_rate = 1//5
  qtds = [y for y in range(1, 401)]
  probability = poisson.pmf(qtds, mean_rate)
  aux = {}

  for qtd, prob in zip(qtds, probability):
    aux[qtd] = prob

  values = []
  values.extend(aux.values())
  maxProb = max(values)
  for chave in aux.keys():
    if aux[chave] == maxProb:
      qtdMax = chave

  period = 400//qtdMax
  tc = [timeA for timeA in range(0, 401, period)]
  return tc

from itertools import cycle
def DCI(df):
  df1 = df.query("Usuário == 'URLLC'")

  df2 = df.query("Usuário == 'eMBB'")
  kmax1 = []
  kmax2 = []

  latencysC1 = np.array(df1['Latency_Cycle'])
  latencysC2 = np.array(df2['Latency_Cycle'])

  rows1 = len(latencysC1)
  rows2 = len(latencysC2)

  columns1 = len(latencysC1[0])-1
  columns2 = len(latencysC2[0])-1

  bwps1 = np.array(df1['BWP [MHz]'])
  bwps2 = np.array(df2['BWP [MHz]'])

  onL1 = np.array(df1['onTime [ms]'])
  onL2 = np.array(df2['onTime [ms]'])

  cycle1 = np.array(df1['Cycle Length [ms]'])
  cycle2 = np.array(df2['Cycle Length [ms]'])


  for bwp in bwps1:
    if bwp == 25000:
      kmax1.append(5)
    elif bwp == 30000:
      kmax1.append(6)
    elif bwp == 40000:
      kmax1.append(8)
    elif bwp == 50000:
      kmax1.append(10)

  for bwp in bwps2:
    if bwp == 25000:
      kmax2.append(5)
    elif bwp == 30000:
      kmax2.append(6)
    elif bwp == 20000:
      kmax2.append(4)
    elif bwp == 5000:
      kmax2.append(1)
    elif bwp == 10000:
      kmax2.append(2)
    elif bwp == 15000:
      kmax2.append(3)

  auxx = [0]*columns1
  aux1 = [auxx]*rows1
  for column1 in range(columns1):
    auxList = []
    for kmax in kmax1:
      if kmax1.index(kmax) not in auxList:
        indexes = [kmax1.index(kmax)]
        for kmaxx in kmax1[kmax1.index(kmax):]:
          if kmaxx == kmax:
            indexes.append(kmax1.index(kmaxx))

        auxList.extend(indexes)
        k = 0
        qtdGroup = onL1[indexes[0]]//kmax
        group = 0
        for ue in indexes:
          if k % kmax == 0 and k != 0:
            group += 1
          if group >= qtdGroup and group % qtdGroup == 0:
            k = 0

          if group < qtdGroup:
            aux1[ue][column1] = group
            k += 1

          elif group >= qtdGroup and group < qtdGroup*2:
            aux1[ue][column1] = group + cycle1[ue]
            k += 1

          elif group >= qtdGroup*2 and group < qtdGroup*3:
            aux1[ue][column1] = group + 2*cycle1[ue]
            k += 1

  auxxx = [0]*columns2
  aux2 = [auxxx]*rows2
  for column2 in range(columns2):
    auxList = []
    for kmax in kmax2:
      if kmax2.index(kmax) not in auxList:
        indexes = [kmax2.index(kmax)]
        for kmaxx in kmax2[kmax2.index(kmax):]:
          if kmaxx == kmax:
            indexes.append(kmax2.index(kmaxx))

        auxList.extend
        k = 0
        qtdGroup = onL2[indexes[0]]//kmax
        group = 0
        for ue in indexes:
          if k % kmax == 0 and k != 0:
            group += 1
          if group >= qtdGroup and group % qtdGroup == 0:
            k = 0

          if group < qtdGroup:
            aux2[ue][column2] = group
            k += 1

          elif group >= qtdGroup and group < qtdGroup*2:
            aux2[ue][column2] = group + cycle2[ue]
            k += 1

          elif group >= qtdGroup*2 and group < qtdGroup*3:
            aux2[ue][column2] = group + 2*cycle2[ue]
            k += 1

  df1['DCI_time'] = aux1
  df2['DCI_time'] = aux2

  df = pd.concat([df1, df2], ignore_index=True)
  return df

def transmissionTime(df, tcs):
  sizes = np.array(df['Packet Size [bytes]'])
  capacities = np.array(df['Shannon_Capacity'])
  tT = []

  for size, capacity in zip(sizes, capacities):
    aux = []
    for tc in tcs:
      aux.append(size//capacity)  #196.08 bytes/ms = 196608 bytes/s = 1.5mbs
    tT.append(aux)

  df['Transmission_time'] = tT

  return df

def totalLatency(df):
  latencyCycle = np.array(df['Latency_Cycle'])
  dci = np.array(df['Transmission_time'])
  tT = np.array(df['DCI_time'])

  totalLatencyaux = latencyCycle + dci
  totalLatency = totalLatencyaux + tT
  df['Total_Latency'] = totalLatency.tolist()
  return df

def lista_simples(lista):
  if isinstance(lista, list):
      return [sub_elem for elem in lista for sub_elem in lista_simples(elem)]
  else:
      return [lista]

def optimizer(x, dfUE):
  df1 = dfUE.query("Usuário == 'URLLC'")
  df2 = dfUE.query("Usuário == 'eMBB'")

  qtd1, discarted1 = df1.shape
  qtd2, discarted2 = df2.shape

  tc = arrivalTimePoisson()
  if qtd1 < qtd2:
    for k in range(0, (qtd1 //20)):
      if k == 0:
        for j in range(0, 20):
          line = min(df1.index[df1['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j])
          deltai = deltaU[dij]
          fij = int(x[20+j])
          onA = fiU[fij]
          offA = int(0.5*onA)
          df1.at[line, 'Cycle Length [ms]'] = deltai
          df1.at[line, 'onTime [ms]'] = onA
          df1.at[line, 'offset [ms]'] = offA

      elif k == 1:
        for j in range(0, 20):
          line = min(df1.index[df1['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 40])
          deltai = deltaU[dij]
          fij = int(x[60 + j])
          onA = fiU[fij]
          offA = int(0.5*onA)
          df1.at[line, 'Cycle Length [ms]'] = deltai
          df1.at[line, 'onTime [ms]'] = onA
          df1.at[line, 'offset [ms]'] = offA

    for k in range(0, (qtd2 //20)):
      if k == 0:
        for j in range(0, 20):
          line = min(df2.index[df2['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 60])
          deltai = deltaE[dij]
          fij = int(x[80+j])
          onA = fiE[fij]
          gij = int(x[100+j])
          offA = gamaE[gij]
          df2.at[line, 'Cycle Length [ms]'] = deltai
          df2.at[line, 'onTime [ms]'] = onA
          df2.at[line, 'offset [ms]'] = offA
      elif k == 1:
        for j in range(0, 20):
          line = min(df2.index[df2['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 120])
          deltai = deltaE[dij]
          fij = int(x[140+j])
          onA = fiE[fij]
          gij = int(x[160+j])
          offA = gamaE[gij]
          df2.at[line, 'Cycle Length [ms]'] = deltai
          df2.at[line, 'onTime [ms]'] = onA
          df2.at[line, 'offset [ms]'] = offA

      elif k == 2:
        for j in range(0, 20):
          line = min(df2.index[df2['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 180])
          deltai = deltaE[dij]
          fij = int(x[200+j])
          onA = fiE[fij]
          gij = int(x[220+j])
          offA = gamaE[gij]
          df2.at[line, 'Cycle Length [ms]'] = deltai
          df2.at[line, 'onTime [ms]'] = onA
          df2.at[line, 'offset [ms]'] = offA

      elif k == 3:
        for j in range(0, 20):
          line = min(df2.index[df2['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 240])
          deltai = deltaE[dij]
          fij = int(x[260+j])
          onA = fiE[fij]
          gij = int(x[280+j]) #300
          offA = gamaE[gij]
          df2.at[line, 'Cycle Length [ms]'] = deltai
          df2.at[line, 'onTime [ms]'] = onA
          df2.at[line, 'offset [ms]'] = offA

  elif qtd2 < qtd1:
    for k in range(0, (qtd2 //20)):
      if k == 0:
        for j in range(0, 20):
          line = min(df2.index[df2['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j])
          deltai = deltaE[dij]
          fij = int(x[20+j])
          onA = fiE[fij]
          gij = int(x[40+j])
          offA = gamaE[gij]
          df2.at[line, 'Cycle Length [ms]'] = deltai
          df2.at[line, 'onTime [ms]'] = onA
          df2.at[line, 'offset [ms]'] = offA

      elif k == 1:
        for j in range(0, 20):
          line = min(df2.index[df2['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 60])
          deltai = deltaE[dij]
          fij = int(x[80 + j])
          onA = fiE[fij]
          gij = int(x[100+j])
          offA = gamaE[gij]
          df2.at[line, 'Cycle Length [ms]'] = deltai
          df2.at[line, 'onTime [ms]'] = onA
          df2.at[line, 'offset [ms]'] = offA

    for k in range(0, (qtd1 //20)):
      if k == 0:
        for j in range(0, 20):
          line = min(df1.index[df1['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 120])
          deltai = deltaU[dij]
          fij = int(x[140+j])
          onA = fiU[fij]
          offA = int(0.5*onA)
          df1.at[line, 'Cycle Length [ms]'] = deltai
          df1.at[line, 'onTime [ms]'] = onA
          df1.at[line, 'offset [ms]'] = offA
      elif k == 1:
        for j in range(0, 20):
          line = min(df1.index[df1['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 160])
          deltai = deltaU[dij]
          fij = int(x[180+j])
          onA = fiU[fij]
          offA = int(0.5*onA)
          df1.at[line, 'Cycle Length [ms]'] = deltai
          df1.at[line, 'onTime [ms]'] = onA
          df1.at[line, 'offset [ms]'] = offA

      elif k == 2:
        for j in range(0, 20):
          line = min(df1.index[df1['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 200])
          deltai = deltaU[dij]
          fij = int(x[220+j])
          onA = fiU[fij]
          offA = int(0.5*onA)
          df1.at[line, 'Cycle Length [ms]'] = deltai
          df1.at[line, 'onTime [ms]'] = onA
          df1.at[line, 'offset [ms]'] = offA

      elif k == 3:
        for j in range(0, 20):
          line = min(df1.index[df1['Cycle Length [ms]'] == 1].tolist())
          dij = int(x[j + 240])
          deltai = deltaU[dij]
          fij = int(x[260+j]) #280
          onA = fiU[fij]
          offA = int(0.5*onA)
          df1.at[line, 'Cycle Length [ms]'] = deltai
          df1.at[line, 'onTime [ms]'] = onA
          df1.at[line, 'offset [ms]'] = offA


  dfUE = pd.concat([df1, df2], ignore_index=True)
  dfUE = latencyCycle(tc, dfUE)
  dfUE = DCI(dfUE)
  dfUE = transmissionTime(dfUE, tc)
  dfUE = totalLatency(dfUE)

  latency = np.array(dfUE['Total_Latency'])
  auxlist = []
  auxlist.append(latency.tolist())
  Lit.extend(lista_simples(auxlist))

  sum1 = 0
  for i in range(0, 100):
    result = ((beta[i] * Pit[i])/ (Pmax*sum(lista_simples(auxlist))))
    sum1 += result
  return sum1

#restricoes
def restricao1(x):
  deltai = []
  fiI = []
  gamaI = []
  for i in range(0, 20):
    indexDU = int(x[i])
    indexFU = int(x[i+20])
    deltai.append(deltaU[indexDU])
    fiI.append(fiU[indexFU])

  deltas = np.array(deltai)
  fiIs = np.array(fiI)

  times = deltas - fiIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao2(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 40])
    deltai = deltaU[dij]
    fij = int(x[60 + j])
    onA = fiU[fij]
    deltaI.append(deltai)
    fiI.append(onA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)

  times = deltas - fiIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao3(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 60])
    deltai = deltaE[dij]
    fij = int(x[80+j])
    onA = fiE[fij]
    gij = int(x[100+j])
    offA = gamaE[gij]

    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao4(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 120])
    deltai = deltaE[dij]
    fij = int(x[140+j])
    onA = fiE[fij]
    gij = int(x[160+j])
    offA = gamaE[gij]

    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao5(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 180])
    deltai = deltaE[dij]
    fij = int(x[200+j])
    onA = fiE[fij]
    gij = int(x[220+j])
    offA = gamaE[gij]
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao6(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 240])
    deltai = deltaE[dij]
    fij = int(x[260+j]) #280
    onA = fiE[fij]
    gij = int(x[280+j])
    offA = gamaE[gij]
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux


cons1 = [{'type': 'ineq', 'fun': restricao1},
        {'type': 'ineq', 'fun': restricao2},
        {'type': 'ineq', 'fun': restricao3},
         {'type': 'ineq', 'fun': restricao4},
         {'type': 'ineq', 'fun': restricao5},
         {'type': 'ineq', 'fun': restricao6}]


a = (0, 20)

bnds1 = 300*[a]

#restricoes2

def restricao7(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j])
    deltai = deltaE[dij]
    fij = int(x[20+j])
    onA = fiE[fij]
    gij = int(x[40+j])
    offA = gamaE[gij]
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao8(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 60])
    deltai = deltaE[dij]
    fij = int(x[80+j])
    onA = fiE[fij]
    gij = int(x[100+j])
    offA = gamaE[gij]
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time < 0:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao9(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 120])
    deltai = deltaU[dij]
    fij = int(x[140+j])
    onA = fiU[fij]
    offA = int(0.5*onA)
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao10(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 160])
    deltai = deltaU[dij]
    fij = int(x[180+j])
    onA = fiU[fij]
    offA = int(0.5*onA)
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao11(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 200])
    deltai = deltaU[dij]
    fij = int(x[220+j])
    onA = fiU[fij]
    offA = int(0.5*onA)
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)

  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

def restricao12(x):
  deltaI = []
  fiI = []
  gamaI = []
  for j in range(0, 20):
    dij = int(x[j + 240])
    deltai = deltaU[dij]
    fij = int(x[260+j]) #280
    onA = fiU[fij]
    offA = int(0.5*onA)
    deltaI.append(deltai)
    fiI.append(onA)
    gamaI.append(offA)

  deltas = np.array(deltaI)
  fiIs = np.array(fiI)
  gamaIs = np.array(gamaI)
  times = deltas - fiIs - gamaIs
  aux = 0
  for time in times:
    if time > 5:
      aux = 0
      break
    else:
      aux = 1

  return aux

cons2 = [{'type': 'ineq', 'fun': restricao7},
        {'type': 'ineq', 'fun': restricao8},
        {'type': 'ineq', 'fun': restricao9},
        {'type': 'ineq', 'fun': restricao10},
        {'type': 'ineq', 'fun': restricao11},
        {'type': 'ineq', 'fun': restricao12}]


b = (0, 20)

bnds2 = 280*[b]

from time import time

# estimativa inicial
x01 = 300*[0]
x02 = 280*[0]

#Vetores para guardar a latência em cada caso
latency_20_80_1 = []
latency_40_60_1 = []
latency_60_40_1 = []
latency_80_20_1 = []

#Vetores para guardar a quantidade de usuários na rede

#Vetores para guardar a potência em cada caso
power_20_80_1 = []
power_40_60_1 = []
power_60_40_1 = []
power_80_20_1 = []

NURLLC = 20
NeMBB = 80

dfUE = inicializaUE(NURLLC, NeMBB)
cont = 0
#for i in range(0, 16):
tempo = 2
start = time()
while (time() - start) <= tempo:
  print("cont = ", cont)
  solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE,))
  cont += 1

latency_20_80_1 = Lit.copy()
power_20_80_1 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

NURLLC = 40
NeMBB = 60

dfUE = inicializaUE(NURLLC, NeMBB)
start = time()
while (time() - start) <= tempo:
  solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE,))

latency_40_60_1 = Lit.copy()
power_40_60_1 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

NURLLC = 60
NeMBB = 40

dfUE = inicializaUE(NURLLC, NeMBB)
start = time()
while (time() - start) <= tempo:
  solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE,))

latency_60_40_1 = Lit.copy()
power_60_40_1 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

NURLLC = 80
NeMBB = 20

dfUE = inicializaUE(NURLLC, NeMBB)
start = time()
while (time() - start) <= tempo:
  solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE,))

latency_80_20_1 = Lit.copy()
power_80_20_1 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

latencies1 = latency_20_80_1 + latency_40_60_1 + latency_60_40_1 + latency_80_20_1

sortL_1 = np.sort(latencies1)
pL_1 = 1.0 * np.arange(len(sortL_1)) / float(len(sortL_1) - 1)

latency_20_80_1.clear()
latency_40_60_1.clear()
latency_60_40_1.clear()
latency_80_20_1.clear()

latency_20_80_1 = None
latency_40_60_1 = None
latency_60_40_1 = None
latency_80_20_1 = None

power1 = power_20_80_1 + power_40_60_1 + power_60_40_1 + power_80_20_1

sortP_1 = np.sort(power1)
pP_1 = 1.0 * np.arange(len(sortP_1)) / float(len(sortP_1) - 1)

power_20_80_1.clear()
power_40_60_1.clear()
power_60_40_1.clear()
power_80_20_1.clear()

power_20_80_1 = None
power_40_60_1 = None
power_60_40_1 = None
power_80_20_1 = None

"""#**Algorithm 2**"""

#Vetores para guardar a latência em cada caso
latency_20_80_2 = []
latency_40_60_2 = []
latency_60_40_2 = []
latency_80_20_2 = []

#Vetores para guardar a quantidade de usuários na rede

#Vetores para guardar a potência em cada caso
power_20_80_2 = []
power_40_60_2 = []
power_60_40_2 = []
power_80_20_2 = []

NURLLC = 20
NeMBB = 80

dfUE = inicializaUE(NURLLC, NeMBB)
dfUE = dfUE.sort_values(by = 'Shannon_Capacity', ascending=False)
start = time()
while (time() - start) <= tempo:
  solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE,))

latency_20_80_2 = Lit.copy()
power_20_80_2 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

NURLLC = 40
NeMBB = 60

dfUE = inicializaUE(NURLLC, NeMBB)
dfUE = dfUE.sort_values(by = 'Shannon_Capacity', ascending=False)
start = time()
while (time() - start) <= tempo:
  solution = minimize(optimizer, x01, method='SLSQP', bounds=bnds1, constraints=cons1, args=(dfUE,))

latency_40_60_2 = Lit.copy()
power_40_60_2 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

NURLLC = 60
NeMBB = 40

dfUE = inicializaUE(NURLLC, NeMBB)
dfUE = dfUE.sort_values(by = 'Shannon_Capacity', ascending=False)
start = time()
while (time() - start) <= tempo:
  solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE,))

latency_60_40_2 = Lit.copy()
power_60_40_2 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

NURLLC = 80
NeMBB = 20

dfUE = inicializaUE(NURLLC, NeMBB)
dfUE = dfUE.sort_values(by = 'Shannon_Capacity', ascending=False)
start = time()
while (time() - start) <= tempo:
  solution = minimize(optimizer, x02, method='SLSQP', bounds=bnds2, constraints=cons2, args=(dfUE,))

latency_80_20_2 = Lit.copy()
power_80_20_2 = Pit.copy()
Lit.clear()
Pit.clear()
del dfUE

latencies2 = latency_20_80_2 + latency_40_60_2 + latency_60_40_2 + latency_80_20_2

sortL_2 = np.sort(latencies2)
pL_2 = 1.0 * np.arange(len(sortL_2)) / float(len(sortL_2) - 1)


latency_20_80_2.clear()
latency_40_60_2.clear()
latency_60_40_2.clear()
latency_80_20_2.clear()

latency_20_80_2 = None
latency_40_60_2 = None
latency_60_40_2 = None
latency_80_20_2 = None

power2 = power_20_80_2 + power_40_60_2 + power_60_40_2 + power_80_20_2

sortP_2 = np.sort(power2)
pP_2 = 1.0 * np.arange(len(sortP_2)) / float(len(sortP_2) - 1)


power_20_80_2.clear()
power_40_60_2.clear()
power_60_40_2.clear()
power_80_20_2.clear()

power_20_80_2 = None
power_40_60_2 = None
power_60_40_2 = None
power_80_20_2 = None

"""#**Plot the two algorithms jointly**"""

plt.plot(sortL_1, pL_1, "-g", label="Algorithm 1")
plt.plot(sortL_2, pL_2, "-r", label="Algorithm2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('latency [ms]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20

plt.show()

plt.plot(sortP_1, pP_1, "-g", label="Algorithm 1")
plt.plot(sortP_2, pP_2, "-b", label="Algorithm 2")
plt.legend(loc="lower right", fontsize=20)
plt.xlabel('Power [mW]', fontsize=20)
plt.ylabel('CDF', fontsize=20)
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20

plt.show()